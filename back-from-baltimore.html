<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Back from Baltimore</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <link rel="stylesheet" href="style.css" type="text/css" media="screen" />
</head>
<body>

<div class="sidebar">

<script src="http://widgets.twimg.com/j/2/widget.js"></script>
<script>
new TWTR.Widget({
  version: 2,
  type: 'profile',
  rpp: 4,
  interval: 6000,
  width: 'auto',
  height: 300,
  theme: {
    shell: {
      background: '#f5f5dc',
      color: '#191970'
    },
    tweets: {
      background: '#ffffff',
      color: '#000000',
      links: '#191970'
    }
  },
  features: {
    scrollbar: false,
    loop: false,
    live: false,
    hashtags: true,
    timestamp: true,
    avatars: false,
    behavior: 'all'
  }
}).render().setUser('sebfisch').start();
</script>

<ul class="nav"
><li
  ><a href="index.html"
    >sebfisch's blog</a
    ></li
  ><li class="current"
  ><a href="back-from-baltimore.html"
    >Back from Baltimore</a
    ></li
  ></ul
>

</div>

<div id="back-from-baltimore"
><h2
  ><a href="back-from-baltimore.html"
    >Back from Baltimore</a
    ></h2
  ><p
  >I visited the 15th ICFP and associated events in Baltimore. This is a summary of some notes I took there.</p
  ><div id="total-parser-combinators"
  ><h3
    >Total Parser Combinators</h3
    ><p
    >Nils Anders Danielsson presented a <a href="http://www.cs.nott.ac.uk/~nad/publications/danielsson-parser-combinators.pdf"
      >paper</a
      > in which he implemented parser combinators in <a href="http://wiki.portal.chalmers.se/agda/"
      >Agda</a
      > together with correctness and termination proofs. An important trick is to use a phantom type as parameter to the parser type which describes whether a parser accepts the empty word.</p
    ><p
    >I wonder how cumbersome it would be to use a similar trick for our <a href="http://sebfisch.github.com/haskell-regexp/regexp-play.pdf"
      >regexp matcher</a
      >. In the paper we describe informally how to build infinite regular expressions such that matching still terminates and it should be possible to express this in the type system too.</p
    ><p
    >Personally, I found his paper interesting to read, because it is a good introduction to Agda and how to use this language to prove properties of real programs. I am certainly inclined to consider Agda myself when I need to do some formal reasoning with my code.</p
    ><p
    >Another interesting aspect of the paper is the discussion of expressivity. To show that every decidable language over a finite alphabet can be described using his recognizers (a preliminary version of the developed parsers), Nils provides a function that translates a decision function for such a language into a recognizer. A similar construction is also possible for regular expressions:</p
    ><pre
    ><code
      >import Text.RegExp

decide :: ([Bool] -&gt; Bool) -&gt; RegExp Bool
decide f | f []      = eps `alt` r
         | otherwise = r
 where r = alt (sym False `seq_` decide (f . (False:)))
               (sym True `seq_` decide (f . (True:)))
</code
      ></pre
    ><p
    >I briefly thought about whether it is possible to extend this construction to decidable languages like</p
    ><pre
    ><code
      >{ nn | n &gt; 0 }
</code
      ></pre
    ><p
    >with an <em
      >infinite</em
      > alphabet by using a custom semiring. My conclusion was: maybe.</p
    ></div
  ><div id="every-bit-counts"
  ><h3
    >Every Bit Counts</h3
    ><p
    >Dimitrios Vytiniotis presented a <a href="http://research.microsoft.com/en-us/people/dimitris/every-bit-counts.pdf"
      >functional pearl</a
      > on encoding typed data by means of question/answer games. The codes generated by proper games have the nice property that no bit is redundant and, basically, every bit sequence corresponds to an encoded value.</p
    ><p
    >I wonder whether standard, derived, encodings of <a href="http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html"
      >Data.Binary</a
      > for algebraic data types have this property as I think it is straightforward to generate a proper question/answer game from a (regular) algebraic data type. I also wonder whether one could go the other way round and generate data types from games, which would probably require dependent types.</p
    ><p
    >As an example for a more complex question/answer game, the paper presents an encoding of typed lambda terms, that is, a compact binary encoding of programs. IIRC, people have long struggled to express typed pograms with dependent types so it would be nice if a (dependent) data type for typed programs could be generated automatically from the game shown in the paper.</p
    ></div
  ><div id="controlflow-vs.dataflow"
  ><h3
    >Controlflow vs. Dataflow</h3
    ><p
    >Jurriaan Hage presented an <a href="http://people.cs.uu.nl/stefan/downloads/holdermans10polyvariant.pdf"
      >approach to analyze controlflow</a
      > which looks similar to <a href="http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/icfp08.pdf"
      >dataflow</a
      > as presented at ICFP 2008. I never managed to analyze dataflow statically, so this paper was a pleasant surprise. I wonder what differences there are between our notion of dataflow and theirs of controlflow if compared carefully.</p
    ></div
  ><div id="teachscheme"
  ><h3
    >TeachScheme</h3
    ><p
    >Matthias Felleisen gave a Keynote on teaching functional programming that I saw with mixed feelings. On one hand the approach seems to work really well and <a href="http://www.htdp.org/"
      >How to Design Programs</a
      > is an invaluable resource for learning how to program. On the other hand I recognized a tension between diversity and uniformity in Matthias’s talk.</p
    ><p
    >He started with a quote from an earlier ICFP (like 10 years ago, or more)</p
    ><blockquote
    ><p
      >Functional programing is typed, lazy, and pure.</p
      ></blockquote
    ><p
    >and disagreed, stating that functional programming can also be untyped, eagerly evaluated, or even incorporate side effects. He considered <em
      >diversity</em
      > an important aspect of functional programming. Then he went on explaining a method for teaching programming that does not allow diverse ways to reach a goal but prescribes a <em
      >uniform</em
      > recipe. There are surely good reasons for a uniform recipe. Most importantly, it is easy to learn. But the contrast to the beginning of the talk which cherished diversity was interesting at least.</p
    ><p
    >Later Matthias went on to explain that he let his students implement games to make his classes more fun. I can imagine that learning to program <em
      >only</em
      > by uniform recipes can be boring. But are games the right answer to this problem? What if students would learn that programming is not only about following recipes but also about creative thinking? What if programming would not only be tought as engeneering but also as an art? It would be less boring for sure.</p
    ></div
  ></div
>

</body>
</html>